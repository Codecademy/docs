---
Title: 'enum'
Description: 'Defines a set of named integer constants in C++ for better code readability and maintainability.'
Subjects:
  - 'Code Foundations'
  - 'Computer Science'
Tags:
  - 'Data Types'
  - 'Enum'
  - 'Variables'
CatalogContent:
  - 'learn-c-plus-plus'
  - 'paths/computer-science'
---

An **`enum`** in C++ is a user-defined [data type](https://www.codecademy.com/resources/docs/cpp/data-types) that defines a set of named integer constants. It provides a way to create symbolic names for a group of related values, making code more readable and maintainable. Enums are particularly useful when representing a fixed set of options or states in the program.

## Syntax of C++ enum

```pseudo
enum enum_name {
  constant1,
  constant2,
  constant3,
  ...
};
```

**Parameters:**

- `enum_name`: The name of the enumeration type
- `constant1, constant2, constant3, ...`: Named constants within the enum

**Return value:**

Enums do not return values directly. They define a new data type that can be used to create variables.

## Example 1: Basic Enum Creation in C++

This example demonstrates how to create a simple enum and use it in a program:

```cpp
#include <iostream>
using namespace std;

// Define an enum for days of the week
enum Day {
  MONDAY,
  TUESDAY,
  WEDNESDAY,
  THURSDAY,
  FRIDAY,
  SATURDAY,
  SUNDAY
};

int main() {
  // Create an enum variable
  Day today = WEDNESDAY;

  // Output the enum value
  cout << "Today is day number: " << today << endl;

  return 0;
}
```

The output of this code is:

```shell
Today is day number: 2
```

In this example, an enum called `Day` is defined with seven constants representing days of the week. By default, `MONDAY` receives the value 0, `TUESDAY` gets 1, and so on. A variable `today` of type `Day` is created and assigned the value `WEDNESDAY`, which holds the integer value 2.

## Example 2: Changing Values in Enum

This example shows how to assign custom values to enum constants:

```cpp
#include <iostream>
using namespace std;

// Define an enum with custom values
enum Priority {
  LOW = 1,
  MEDIUM = 5,
  HIGH = 10,
  URGENT = 15
};

int main() {
  // Create enum variables
  Priority taskPriority = HIGH;
  Priority alertLevel = URGENT;

  // Display the values
  cout << "Task priority: " << taskPriority << endl;
  cout << "Alert level: " << alertLevel << endl;

  // Compare enum values
  if (alertLevel > taskPriority) {
    cout << "Alert level is higher than task priority" << endl;
  }

  return 0;
}
```

The output of this code is:

```shell
Task priority: 10
Alert level: 15
Alert level is higher than task priority
```

This example demonstrates how to assign specific integer values to enum constants. When a value is set for one constant, subsequent constants automatically increment from that value unless explicitly assigned. In this case, `LOW` is 1, `MEDIUM` is 5, `HIGH` is 10, and `URGENT` is 15.

## Example 3: Enum in a Switch Statement

This example demonstrates using enums with switch statements for control flow:

```cpp
#include <iostream>
using namespace std;

// Define an enum for traffic light colors
enum TrafficLight {
  RED,
  YELLOW,
  GREEN
};

int main() {
  TrafficLight currentLight = RED;

  // Use enum in switch statement
  switch (currentLight) {
    case RED:
      cout << "Stop! Red light is on." << endl;
      break;
    case YELLOW:
      cout << "Caution! Yellow light is on." << endl;
      break;
    case GREEN:
      cout << "Go! Green light is on." << endl;
      break;
    default:
      cout << "Unknown light state." << endl;
  }

  // Simulate traffic light sequence
  cout << "\nTraffic light sequence:" << endl;
  for (int i = RED; i <= GREEN; i++) {
    TrafficLight light = static_cast<TrafficLight>(i);
    switch (light) {
      case RED:
        cout << "RED -> ";
        break;
      case YELLOW:
        cout << "YELLOW -> ";
        break;
      case GREEN:
        cout << "GREEN";
        break;
    }
  }
  cout << endl;

  return 0;
}
```

The output generated by this code is:

```shell
Stop! Red light is on.

Traffic light sequence:
RED -> YELLOW -> GREEN
```

This example shows how enums work perfectly with switch statements, providing clear and readable control flow. The enum values make the code self-documenting and easier to maintain than using magic numbers.

## Codebyte Example: Create Enum Class

This example demonstrates scoped enums (`enum` class) introduced in C++ 11, which provide better type safety and scope control:

```codebyte/cpp
#include <iostream>
using namespace std;

// Define enum class for better type safety
enum class Color {
  RED,
  GREEN,
  BLUE
};

enum class Size {
  SMALL,
  MEDIUM,
  LARGE
};

int main() {
  // Create enum class variables
  Color favoriteColor = Color::RED;
  Size shirtSize = Size::MEDIUM;

  // Display enum class values (requires casting)
  cout << "Favorite color code: " << static_cast<int>(favoriteColor) << endl;
  cout << "Shirt size code: " << static_cast<int>(shirtSize) << endl;

  // Enum class prevents implicit conversions
  // This would cause compilation error:
  // if (favoriteColor == Size::SMALL) { ... }

  // Use enum class in switch statement
  switch (favoriteColor) {
    case Color::RED:
      cout << "You chose red color!" << endl;
      break;
    case Color::GREEN:
      cout << "You chose green color!" << endl;
      break;
    case Color::BLUE:
      cout << "You chose blue color!" << endl;
      break;
  }

  return 0;
}
```

The text provides information about the strengths of the **Enum class** compared to regular enums. Key advantages include strong typing, which avoids implicit conversion to integers, reduced namespace pollution, and prevention of naming conflicts. Accessing enum class values requires the use of the scope resolution operator (`::`).

## Frequently Asked Questions

### 1. Why use enum instead of array?

Enums are used to define a set of named constants that represent fixed values, while arrays store collections of data. Enums provide compile-time constants that make code more readable and maintainable. Unlike arrays, enums don't allocate memory for storing values at runtime - they're purely symbolic names for integer constants.

### 2. How to get enum value in C++?

You can get the integer value of an enum by simply using the enum constant in an integer context or by explicitly casting it. For regular enums, implicit conversion to int works, but for enum classes, you need `static_cast<int>(enum_value)`.

### 3. Can enum values be strings?

No, enum values in C++ are always integers. However, you can create arrays or maps to associate enum values with strings for display purposes.

### 4. What's the difference between enum and enum class?

`enum` class (scoped enums) introduced in C++11 provides better type safety, doesn't pollute the namespace, and prevents implicit conversions. Regular enums allow implicit conversion to integers and their constants are accessible without scope resolution.
